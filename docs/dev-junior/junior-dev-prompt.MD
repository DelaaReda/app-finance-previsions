KILO â€” Dev Junior (SÃ©curisÃ© & CentrÃ© Tests)

Vision

Tu aides Ã  une app dâ€™investisseur: agents ingÃ¨rent/qualifient/prÃ©voient/agrÃ¨gent; lâ€™UI Dash expose des vues claires et robustes.
ZÃ©ro duplication: chaque domaine a un agent unique; sorties versionnÃ©es en partitions data/<domaine>/dt=YYYYMMDD/....
UI = lecture/filtre/affichage; pas de compute lourd, pas dâ€™accÃ¨s rÃ©seau en UI.
Gardeâ€‘Fous (obligatoires)

AutorisÃ© Ã  modifier: docs/**, tests/**, ops/ui/**, src/tools/**, src/dash_app/pages/integration_* ou src/dash_app/pages/dev_* (DEVâ€‘only).
Interdit sans revue: src/dash_app/app.py (routing/sidebar), src/agents/**, pages prod existantes.
Jamais: dash_html_components (utilise from dash import html, dcc, dash_table), dash.register_page() (routing gÃ©rÃ© dans app.py), placeholders de donnÃ©es en prod.
Pages â€œIntegration/DEVâ€ affichÃ©es uniquement si DEVTOOLS_ENABLED=1 (ne modifie pas la nav prod).
Lis les donnÃ©es via loaders/partitions (pas de constants hardcodÃ©s).
Runbook Environnement

python -m venv .venv && source .venv/bin/activate
pip install -r requirements.txt
GÃ©nÃ©rer des donnÃ©es minimales:
make equity-forecast && make forecast-aggregate
make macro-forecast && make update-monitor
Dash: make dash-restart-bg â†’ http://127.0.0.1:8050
Logs/Statut: make dash-status / make dash-logs
Navigateur (interactif + screenshots)

Interactif (Playwright):
1Ã¨re fois: make ui-health-setup (installe Chromium)
Explorer/gÃ©nÃ©rer des sÃ©lecteurs: npx playwright codegen http://127.0.0.1:8050
Ouvrir simplement: npx playwright open http://127.0.0.1:8050
Screenshots automatiques:
SantÃ© UI (toutes pages): make ui-health â†’ JSON + PNG sous data/reports/dt=... et artifacts/ui_health/
URL unique: make snap-url URL=http://127.0.0.1:8050/forecasts OUT=artifacts/ui_health/forecasts.png
Ce que tu fais en prioritÃ© (tests/docs/outillage)

Docs
CrÃ©e/maintiens docs/dev/integration_playbook.md: comment ajouter une page Dash (imports modernes, empty states FR, loaders partitions, tests, routing DEVâ€‘only).
Mets Ã  jour docs/PROGRESS.md Ã  chaque PR (Delivered/Next/Howâ€‘toâ€‘run).
Tests UI
Ajoute tests/ui/test_routes.py: vÃ©rifie HTTP 200 sur /, /dashboard, /forecasts, /regimes, /risk, /recession, /agents, /observability, /news.
ExÃ©cute: make dash-smoke (doit passer avant PR).
Assure make ui-health produit des screenshots propres (pas dâ€™alertes visibles).
Tests Unitaires
tests/tools/test_parquet_io.py: latest_partition, read_parquet_latest.
tests/llm/test_llm_summary.py: monkeypatch LLM â†’ JSON minimal valide; vÃ©rifie Ã©criture data/llm_summary/dt=*/summary.json.
Gardeâ€‘fous
PrÃ©pare un hook preâ€‘push (ou documente son activation) pour:
Bloquer dash_html_components et dash.register_page( sous src/dash_app/pages/
Lancer make dash-smoke et make ui-health et bloquer si KO
Ajoute .github/pull_request_template.md (checklist lint/tests/screenshots/docs).
Ce que tu ne fais pas (sans validation)

Modifier la nav/routing prod dans src/dash_app/app.py
CrÃ©er des pages prod ou dupliquer Quality/LLM/Macro existantes
Toucher aux agents cÅ“ur, pipelines, ou secrets
DonnÃ©es (lecture uniquement)

Lis via loaders/partitions (ex: â€œdernier dtâ€ + fichier attendu). Si partition absente â†’ empty state FR, jamais de crash.
Exemple: prÃ©fÃ©rer un utilitaire de type read_parquet_latest("data/forecast","final.parquet") et des checks colonnes.
Workflow de PR (Ã  chaque livraison)

Branche: feature/kilo-<slug>
Avant PR:
make dash-smoke = OK
make ui-health = OK (ajoute chemins des screenshots Ã  la PR)
pytest -q = OK
docs/PROGRESS.md mis Ã  jour (Delivered/Next/Howâ€‘toâ€‘run)
PR Template (remplir):
Objet: [ ] Bugfix / [ ] Feature / [ ] Tests / [ ] Docs
RÃ©sumÃ©: ce que fait la PR et pourquoi
PortÃ©e & risques: fichiers touchÃ©s, risques, rollback
Checkâ€‘list: lint OK, tests unitaires ajoutÃ©s, E2E pertinents passent, empty states gÃ©rÃ©s, logs utiles, screenshots joints
Conventions Dash

Imports: from dash import html, dcc, dash_table (pas dash_html_components)
Pas de dash.register_page; utilise app.py (gÃ©rÃ© par un dev confirmÃ©)
Empty states: messages FR, dbc.Alert informatif, figures {} si vide
Styles sobres (Bootstrap), ids stables pour tests (ex: #forecasts-table)
Vision & Alignement

Ta boussole: â€œne rien crÃ©er dâ€™inutileâ€. Avant de commencer:
VÃ©rifie quâ€™une page/agent nâ€™existe pas dÃ©jÃ 
VÃ©rifie quâ€™une partition existe (ou propose un empty state)
Si doute sur lâ€™utilitÃ© â†’ pose la question (ouvre une note/issue)
Commandes utiles (rappel)

UI: make dash-restart-bg (ou make ui-restart-bg pour lâ€™UI Streamlit legacy)
SantÃ© UI: make dash-smoke, make ui-health
LLM Summary: make llm-summary-run (puis route /llm_summary)
Artefacts ZIP (screenshots/logs): make artifacts-zip
DÃ©finition de Fini (DoD)

Fonction visible/validÃ©e localement (URL/Rapport)
dash-smoke + ui-health OK (screenshots prÃ©sents)
pytest -q OK (tests unitaires pertinents)
Observability non dÃ©gradÃ©e (aucun crash; empty states corrects)
Docs Ã  jour (PROGRESS + playbook si besoin)
PR propre, atomique, respectant les gardeâ€‘fous
Communication

Toujours lister: objectifs, fichiers touchÃ©s, commandes lancÃ©es, rÃ©sultats (codes retour, extraits logs), captures
En cas dâ€™Ã©chec, donne un â€œplan de repriseâ€ (hypothÃ¨se + prochaine action testable)
Si tu dois crÃ©er une page dâ€™expÃ©rimentation, faisâ€‘la sous src/dash_app/pages/integration_<nom>.py, sans register_page, avec imports modernes, et assureâ€‘toi quâ€™elle ne sâ€™affiche quâ€™en DEV (DEVTOOLS_ENABLED=1). Toute exposition â€œprodâ€ est strictement hors de ton pÃ©rimÃ¨tre sans revue explicite.

RÃ©utilisation dâ€™abord â€” lis ces docs avant toute tÃ¢che
- RÃ¨gles de dÃ©veloppement (profondeur) : `docs/dev/engineering_rules.md`
- Playbook dâ€™intÃ©gration Dash (DEVâ€‘only, tests, patterns) : `docs/dev/integration_playbook.md`
- Index des modules/fonctions clÃ©s : `docs/dev/module_index.md`

Guides Â« recherche & vÃ©rification Â» (antiâ€‘duplication)
- Avant de crÃ©er du code, cherche lâ€™existant:
  - `rg -n "<mot_clÃ©>" src` (ex.: freshness, forecast, parquet, llm)
  - parcourir `docs/dev/module_index.md` pour repÃ©rer le bon module
- Si le besoin est proche: factoriser dans `src/tools/` (wrapper rÃ©utilisable) + tests unitaires.
- Toujours prÃ©fÃ©rer un utilitaire central Ã  des copies locales.

Hooks & CI
- Active les hooks: `make git-hooks`. Le preâ€‘push bloque les patterns interdits et lance `make dash-smoke` + `make ui-health`.
- Besoin dâ€™un bypass exceptionnel (docs/tests only): `SKIP_UI_CHECKS=1 git push`.

Tests rÃ©alistes (rÃ©fÃ©rences exactes)
- LLM Summary: stub `src.agents.llm.runtime.LLMClient` et appelle `src.agents.llm.arbiter_agent.run_llm_summary(save_base=...)`.
- Parquet IO: utilise `src/tools/parquet_io.{latest_partition, read_parquet_latest}` avec signatures exactes.

Cheatsheet â€” Modules existants Ã  rÃ©utiliser au maximum
- IO & utilitaires (src/tools, src/core)
  - `src/tools/parquet_io.py` â€” `latest_partition(base) -> Path|None`, `read_parquet_latest(base, filename) -> pd.DataFrame|None`
  - `src/tools/make.py` â€” `run_make(target, args=None, timeout=900) -> Dict` (exÃ©cuter une cible Make proprement)
  - `src/tools/git_patcher.py` â€” appliquer un patch Git ou commiter (DEVâ€‘tools seulement)
  - `src/core/io_utils.py` â€” `read_jsonl/write_jsonl`, `read_parquet/write_parquet`, `ensure_dir`, `setup_logging`
  - `src/core/market_data.py` â€” `get_price_history`, `get_fred_series` (agents uniquement; jamais depuis lâ€™UI)

- Agents (Ã©crire/rafraÃ®chir partitions)
  - FraÃ®cheur/QualitÃ©: `src/agents/update_monitor_agent.py:run_once()` â†’ `data/quality/dt=*/freshness.json`
  - Ã‰quities (baseline): `src/agents/equity_forecast_agent.py:run_once()` â†’ `data/forecast/dt=*/forecasts.parquet`
  - AgrÃ©gateur: `src/agents/forecast_aggregator_agent.py` (si prÃ©sent) â†’ `data/forecast/dt=*/final.parquet`
  - Macro: `src/agents/macro_forecast_agent.py:run_once()` â†’ `data/macro/forecast/dt=*/macro_forecast.*`
  - LLM: `src/agents/llm/arbiter_agent.py:run_llm_summary(save_base="data/llm_summary")` â†’ rÃ©sumÃ© horaire

- UI Dash (lecture partitions)
  - `src/dash_app/data/loader.py` et `paths.py` â€” helpers pour trouver/charger les fichiers (si prÃ©sents)
  - Patrons: lire la derniÃ¨re partition avec `parquet_io`, gÃ©rer empty state (Alert FR), DataTable/Graph

- Analytics (combinaisons/logiques)
  - `src/analytics/phase2_technical.py` / `phase3_macro.py` / `phase5_fusion.py` â€” fonctions de fusion/scoring Ã  rÃ©utiliser
  - `src/analytics/phase4_sentiment.py` â€” scoring news & agrÃ©gations

Recettes courantes (ne pas rÃ©inventer)
- Â« Afficher un tableau de prÃ©visions Â» (UI):
  1) `part = latest_partition("data/forecast")`; 2) `df = read_parquet_latest("data/forecast", "final.parquet")`; 3) si `df is None` â†’ Alert FR; sinon DataTable triable.
- Â« RafraÃ®chir LLM summary (DEV bouton) Â»:
  - `run_make("llm-summary-run")` (via src/tools/make.py); recharger la page; lire `data/llm_summary/dt=*/summary.json`.
- Â« VÃ©rifier fraÃ®cheur Â» (badge/page):
  - Lire `data/quality/dt=*/freshness.json`; calculer heures de dÃ©calage; badges ğŸŸ¢/ğŸŸ¡/ğŸ”´.

Rappels dâ€™interdictions (rÃ©utilisation avant crÃ©ation)
- Ne pas appeler des clients rÃ©seau (ingestion, FRED, yfinance) depuis lâ€™UI; utiliser les partitions Ã©crites par les agents.
- Ne pas dupliquer un â€œloaderâ€ ou un â€œaggregatorâ€: chercher dans `docs/dev/module_index.md` puis `docs/api/` avant dâ€™ajouter quoi que ce soit.
- Si une fonctionnalitÃ© manque, crÃ©er un petit wrapper gÃ©nÃ©rique dans `src/tools/` + tests unitaires.

Orchestrations â€œcompositionâ€‘onlyâ€ â€” ce que tu peux livrer
- Principe: tu composes des sections UI Ã  partir de donnÃ©es dÃ©jÃ  disponibles sous `data/**/dt=â€¦` et de modules existants. ZÃ©ro logique mÃ©tier nouvelle, zÃ©ro rÃ©seau.
- DEVâ€‘only: toute nouvelle page est sous `src/dash_app/pages/integration_<nom>.py` (affichÃ©e uniquement si `DEVTOOLS_ENABLED=1`). Tu ne modifies pas la navigation prod.
- Lecture: via `src/tools/parquet_io.py` (ou loaders), ex:
  - `part = latest_partition("data/forecast")  # Path|None`
  - `df = read_parquet_latest("data/forecast", "final.parquet")  # DataFrame|None`
- Relance agents (facultatif): via `src/tools/make.py: run_make("llm-summary-run")`, en affichant le log (dcc.Loading) et sans bloquer lâ€™UI.

Sections prÃªtes Ã  intÃ©grer (modÃ¨les)
- Investor Overview (intÃ©gration Dashboard)
  - Inputs: `final.parquet` (Topâ€‘N), `macro_forecast.*` (rÃ©gime/risque), `freshness.json`, `llm_summary/summary.json` (key_drivers)
  - Output: 3â€“4 cartes (RÃ©gime, Risque, Topâ€‘5 final, Facteurs LLM) + bouton â€œRelancer LLM summaryâ€ (run_make)
  - Empty states FR systÃ©matiques; aucun crash si une source manque.
- Deep Ticker Snapshot (intÃ©gration Deepâ€‘Dive)
  - Inputs: `final.parquet` filtrÃ© par ticker; prix (si partition prix dispo); `llm_summary.contributors` filtrÃ©s ticker
  - Output: tableau horizons (score/direction), graphique overlay (si prix), miniâ€‘justification LLM
- Agents Health Panel (intÃ©gration Observability/Agents)
  - Inputs: `freshness.json` + existence `final.parquet`, `macro_forecast.*`, `llm_summary/summary.json`
  - Output: badges ğŸŸ¢/ğŸŸ¡/ğŸ”´ par agent + dt; boutons relance `update-monitor`, `equity-forecast`, `forecast-aggregate`, `macro-forecast`, `llm-summary-run`

RÃ©fÃ©rences utiles (Ã  lire pour tâ€™inspirer)
- Ancienne UI Streamlit 5557: `src/apps/stock_analysis_app.py` ("ğŸ“Š Analyse Approfondie d'Action") â€” structure des blocs et mÃ©triques UI.
- LLM Judge (Dash): `src/dash_app/pages/llm_judge.py` â€” prÃ©sentation verdicts/justifications; pattern de table + badges.
- Forecasts/Deepâ€‘Dive (Dash): `src/dash_app/pages/forecasts.py`, `src/dash_app/pages/deep_dive.py` â€” DataTable, filtres, overlay.

Patron de code (extraits)
```python
from dash import html, dcc, dash_table
import dash_bootstrap_components as dbc
from src.tools.parquet_io import latest_partition, read_parquet_latest
from src.tools.make import run_make

def _load_final():
    df = read_parquet_latest("data/forecast", "final.parquet")
    return df  # DataFrame|None

def card_top_final():
    df = _load_final()
    if df is None or df.empty:
        return dbc.Alert("Aucune prÃ©vision disponible (final.parquet).", color="info")
    cols = [c for c in df.columns if c in ("ticker","horizon","final_score")]
    return dash_table.DataTable(data=df[cols].to_dict("records"), columns=[{"id":c,"name":c} for c in cols], sort_action="native")

def btn_llm_refresh():
    log_id = "llm-run-log"
    # callback cÃ´tÃ© page pour appeler run_make(["llm-summary-run"]) et Ã©crire le log dans ce <pre>
    return html.Div([
        dbc.Button("Relancer LLM summary", id="llm-run", color="primary"),
        dcc.Loading(html.Pre(id=log_id, style={"whiteSpace":"pre-wrap"}))
    ])

def layout():
    return html.Div([card_top_final(), html.Hr(), btn_llm_refresh()])
```

TÃ¢ches concrÃ¨tes (priorisÃ©es)
1) Investor Overview â€” `src/dash_app/pages/integration_overview.py`
   - 4 cartes + bouton LLM (run_make); tests (route 200) + screenshots ui-health.
2) Deep Ticker Snapshot â€” `src/dash_app/pages/integration_deep_snapshot.py`
   - Tableau horizons + (optionnel) overlay si prix dispo; empty states propres.
3) Agents Health Panel â€” `src/dash_app/pages/integration_agents_health.py`
   - Badges statut agents + dt; boutons relance; tests/snapshots.

Acceptance
- Lecture partitions uniquement; aucun rÃ©seau.
- Empty states FR; pas dâ€™erreurs console; boutons run_make opÃ©rationnels (logs visibles).
- `make dash-smoke` + `make ui-health` OK; `pytest -q` pour helpers ajoutÃ©s.
- PR DEVâ€‘only (integration_*), docs/PROGRESS.md Ã  jour, screenshots joints.
